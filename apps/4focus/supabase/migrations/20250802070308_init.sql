create table public.tasks (
  id bigint generated by default as identity primary key,
  creation_date timestamptz default now() not null,
  update_date timestamptz default now() not null,
  title text not null check (char_length(trim(title)) >= 3 and char_length(trim(title)) <= 280),
  description text check (description is null or (char_length(trim(description)) >= 10 and char_length(trim(description)) <= 500)),
  priority text not null default 'normal' check (priority in ('urgent', 'high', 'normal', 'low')),
  status text not null default 'todo' check (status in ('todo', 'pending', 'done')),
  estimated_duration_minutes integer not null check (estimated_duration_minutes > 0),
  user_id uuid not null references auth.users (id) on delete cascade
);

comment on table public.tasks is 'Tasks for users.';
comment on column public.tasks.user_id is 'Owner of the task.';
comment on column public.tasks.estimated_duration_minutes is 'User''s estimated time in minutes to complete the task. Must be a positive integer.';


create or replace function public.handle_updated_at()
returns trigger as $$
begin
  new.update_date = now();
  return new;
end;
$$ language plpgsql set search_path = '';

create trigger on_task_update
before update on public.tasks
for each row
execute procedure public.handle_updated_at();


alter table public.tasks enable row level security;

create policy "Users can view their own tasks." on public.tasks
  for select using (auth.uid() = user_id);

create policy "Users can insert their own tasks." on public.tasks
  for insert with check (auth.uid() = user_id);

create policy "Users can update their own tasks." on public.tasks
  for update using (auth.uid() = user_id) with check (auth.uid() = user_id);

create policy "Users can delete their own tasks." on public.tasks
  for delete using (auth.uid() = user_id);

-- Section for History / Audit Trail

create table public.tasks_history (
  id bigserial primary key,
  task_id bigint not null,
  operation char(1) not null check (operation in ('I', 'U', 'D')), -- I for Insert, U for Update, D for Delete
  changed_at timestamptz not null default now(),
  
  -- Mirrored columns from tasks
  creation_date timestamptz,
  update_date timestamptz,
  title text,
  description text,
  priority text,
  status text,
  user_id uuid
);

comment on table public.tasks_history is 'History of changes for the tasks table.';
comment on column public.tasks_history.operation is 'I for Insert, U for Update, D for Delete.';

alter table public.tasks_history enable row level security;

create policy "Users can view their own task history." on public.tasks_history
  for select using (auth.uid() = user_id);

create or replace function public.copy_to_tasks_history()
returns trigger as $$
begin
  if (TG_OP = 'INSERT') then
    insert into public.tasks_history (task_id, operation, creation_date, update_date, title, description, priority, status, user_id)
    values (NEW.id, 'I', NEW.creation_date, NEW.update_date, NEW.title, NEW.description, NEW.priority, NEW.status, NEW.user_id);
    return NEW;
  end if;
  if (TG_OP = 'UPDATE') then
    insert into public.tasks_history (task_id, operation, creation_date, update_date, title, description, priority, status, user_id)
    values (OLD.id, 'U', OLD.creation_date, OLD.update_date, OLD.title, OLD.description, OLD.priority, OLD.status, OLD.user_id);
    return NEW;
  elsif (TG_OP = 'DELETE') then
    insert into public.tasks_history (task_id, operation, creation_date, update_date, title, description, priority, status, user_id)
    values (OLD.id, 'D', OLD.creation_date, OLD.update_date, OLD.title, OLD.description, OLD.priority, OLD.status, OLD.user_id);
    return OLD;
  end if;
  return null;
end;
$$ language plpgsql security definer set search_path = '';

create trigger tasks_history_trigger
after insert or update or delete on public.tasks
for each row execute procedure public.copy_to_tasks_history();

-- Focus sessions

create table public.focus_sessions (
  id bigint generated by default as identity primary key,
  task_id bigint references public.tasks(id) on delete set null,
  user_id uuid not null references auth.users(id) on delete cascade,
  started_at timestamptz not null default now(),
  ended_at timestamptz,
  status text not null default 'active' check (status in ('active', 'completed', 'abandoned')),
  total_interruptions integer not null default 0
);

comment on table public.focus_sessions is 'High-level state for a user focus session. Decoupled from tasks to preserve history.';
comment on column public.focus_sessions.task_id is 'Link to the task. Becomes NULL if the task is deleted.';
comment on column public.focus_sessions.user_id is 'Link to the user. Cascades on delete as sessions are owned by users.';
comment on column public.focus_sessions.total_interruptions is 'Denormalized count of interruptions for performance. Incremented via API calls.';


-- Row Level Security for the new table
alter table public.focus_sessions enable row level security;

create policy "Users can view their own sessions." on public.focus_sessions
  for select using (auth.uid() = user_id);

create policy "Users can insert their own sessions." on public.focus_sessions
  for insert with check (auth.uid() = user_id);

create policy "Users can update their own sessions." on public.focus_sessions
  for update using (auth.uid() = user_id) with check (auth.uid() = user_id);

create policy "Users can delete their own sessions." on public.focus_sessions
  for delete using (auth.uid() = user_id);


-- Index to enforce that a user can only have one active session at a time
create unique index one_active_session_per_user_idx
  on public.focus_sessions (user_id)
  where (status = 'active');

comment on index public.one_active_session_per_user_idx is 'Ensures a user can only have one active focus session at a time.';

-- Trigger to create a focus session when a task is marked as "pending"
create or replace function public.handle_new_pending_task()
returns trigger as $$
begin
  -- Check if the task status was just updated to 'pending'
  if new.status = 'pending' and old.status is distinct from 'pending' then
    -- Insert a new active focus session for the task's owner
    insert into public.focus_sessions (task_id, user_id, status)
    values (new.id, new.user_id, 'active');
  end if;
  return new;
end;
$$ language plpgsql security definer;

create trigger on_task_pending_create_session
  after update of status on public.tasks
  for each row
  execute procedure public.handle_new_pending_task();

comment on trigger on_task_pending_create_session on public.tasks
is 'When a task''s status is updated to "pending", automatically create a new active focus session.';