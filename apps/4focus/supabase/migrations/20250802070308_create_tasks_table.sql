create table public.tasks (
  id bigint generated by default as identity primary key,
  creation_date timestamptz default now() not null,
  update_date timestamptz default now() not null,
  title text not null check (char_length(trim(title)) >= 3 and char_length(trim(title)) <= 280),
  description text check (description is null or (char_length(trim(description)) >= 10 and char_length(trim(description)) <= 500)),
  priority text not null default 'normal' check (priority in ('urgent', 'high', 'normal', 'low')),
  status text not null default 'todo' check (status in ('todo', 'pending', 'done')),
  owner_id uuid not null references auth.users (id) on delete cascade
);

comment on table public.tasks is 'Tasks for users.';
comment on column public.tasks.owner_id is 'Owner of the task.';


create or replace function public.handle_updated_at()
returns trigger as $$
begin
  new.update_date = now();
  return new;
end;
$$ language plpgsql;

create trigger on_task_update
before update on public.tasks
for each row
execute procedure public.handle_updated_at();


alter table public.tasks enable row level security;

create policy "Users can view their own tasks." on public.tasks
  for select using (auth.uid() = owner_id);

create policy "Users can insert their own tasks." on public.tasks
  for insert with check (auth.uid() = owner_id);

create policy "Users can update their own tasks." on public.tasks
  for update using (auth.uid() = owner_id) with check (auth.uid() = owner_id);

create policy "Users can delete their own tasks." on public.tasks
  for delete using (auth.uid() = owner_id);

-- Section for History / Audit Trail

create table public.task_history (
  history_id bigserial primary key,
  task_id bigint not null,
  operation char(1) not null check (operation in ('U', 'D')), -- U for Update, D for Delete
  changed_at timestamptz not null default now(),
  
  -- Mirrored columns from tasks
  creation_date timestamptz,
  update_date timestamptz,
  title text,
  description text,
  priority text,
  status text,
  owner_id uuid
);

comment on table public.task_history is 'History of changes for the tasks table.';
comment on column public.task_history.operation is 'U for Update, D for Delete.';

create or replace function public.copy_to_task_history()
returns trigger as $$
begin
  if (TG_OP = 'UPDATE') then
    insert into public.task_history (task_id, operation, creation_date, update_date, title, description, priority, status, owner_id)
    values (OLD.id, 'U', OLD.creation_date, OLD.update_date, OLD.title, OLD.description, OLD.priority, OLD.status, OLD.owner_id);
    return NEW;
  elsif (TG_OP = 'DELETE') then
    insert into public.task_history (task_id, operation, creation_date, update_date, title, description, priority, status, owner_id)
    values (OLD.id, 'D', OLD.creation_date, OLD.update_date, OLD.title, OLD.description, OLD.priority, OLD.status, OLD.owner_id);
    return OLD;
  end if;
  return null;
end;
$$ language plpgsql;

create trigger tasks_history_trigger
after update or delete on public.tasks
for each row execute procedure public.copy_to_task_history();
